<!DOCTYPE html>
<html lang="en-US">

<head>

<title>Activity Analyzer</title>

<link rel="stylesheet" type="text/css" href="../css/normalize.css">
<link rel="stylesheet" type="text/css" href="../css/site.css">

<meta charset="UTF-8">
<meta name="description" content="Map of locations in which the user has logged Strava activities">
<meta name="keywords" content="location summary">
<meta name="viewport" content="initial-scale=1.0, user-scalable=no" />

<link rel="shortcut icon" href="../images/favicon.ico" >

</head>

<body>

<style type="text/css">
    html { height: 100% }
    body { height: 100%; margin: 0; padding: 0 }
    div { margin: 0px }

    div.bar
    {
        display: inline-block;
        width: 20px;
        height: 75px;	/* Gets overriden by D3-assigned height below */
        background-color: teal;
    }

    path
    {
        stroke: steelblue;
        stroke-width: 2;
        fill: none;
    }

    .axis path,
    .axis line
    {
        fill: none;
        stroke: #000;
        stroke-width: 1;
        shape-rendering: crispEdges;
    }
</style>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.js" integrity="sha256-DZAnKJ/6XZ9si04Hgrsxu/8s717jcIzLy3oi35EouyE=" crossorigin="anonymous"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" integrity="sha256-KM512VNnjElC30ehFwehXjx1YCHPiQkOPmqnrWtpccM=" crossorigin="anonymous"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.17/d3.min.js" integrity="sha256-dsOXGNHAo/syFnazt+KTBsCQeRmlcW1XKL0bCK4Baec=" crossorigin="anonymous"></script>

<script type="text/javascript">
    /// @function pad
    /// Utility function for padding a number with leading zeroes.
    function pad(num, size)
    {
        var s = "000000000" + num;
        return s.substr(s.length - size);
    }

    /// @function convert_seconds_to_hours_mins_secs
    /// Converts seconds to HH:MM:SS format.
    function convert_seconds_to_hours_mins_secs(seconds_in)
    {
        seconds = seconds_in % 60;
        minutes = Math.trunc(seconds_in / 60);
        hours = Math.trunc(minutes / 60);
        minutes = Math.trunc(minutes % 60);
        out_str = pad(hours.toFixed(0), 2) + ":" + pad(minutes.toFixed(0), 2) + ":" + pad(seconds.toFixed(0), 2);
        return out_str;
    }

    /// @function unix_time_ms_to_local_string
    function unix_time_ms_to_local_string(unix_time)
    {
        let date = new Date(unix_time);
        return date.toLocaleString();
    }

    /// @function unix_time_ms_to_local_date_string
    function unix_time_ms_to_local_date_string(unix_time)
    {
        let date = new Date(unix_time);
        return date.toLocaleDateString();
    }

    /// @function convert_distance_to_unit_system_str
    /// Converts meters to whatever the preferred units are and formats it as a string.
    function convert_distance_to_unit_system_str(unit_system, meters_traveled)
    {
        if (unit_system == "Metric")
        {
            let km = meters_traveled / 1000.0;
            return km.toFixed(2).toString() + " kms";
        }
        let miles = meters_traveled * 0.000621371;
        return miles.toFixed(2).toString() + " miles";
    }

    /// @function convert_vertical_distance_to_unit_system_str
    /// Converts meters to whatever the preferred units are and formats it as a string.
    function convert_vertical_distance_to_unit_system_str(unit_system, meters_climbed)
    {
        if (unit_system == "Metric")
        {
            return meters_climbed.toFixed(2).toString() + " meters";
        }
        let feet = meters_climbed * 3.28084;
        return feet.toFixed(2).toString() + " feet";
    }

    /// @function convert_speed_to_unit_system_str
    /// Converts meters/second to whatever the preferred units are and formats it as a string.
    function convert_speed_to_unit_system_str(unit_system, speed)
    {
        if (unit_system == "Metric")
        {
            let km = speed * 3.6;
            return km.toFixed(2).toString() + " km/hr";
        }
        let miles = speed * 2.23694;
        return miles.toFixed(2).toString() + " miles/hr";
    }

    /// @function convert_pace_to_unit_system_str
    /// Converts meters/minute to whatever the preferred units are and formats it as a string.
    function convert_pace_to_unit_system_str(unit_system, pace)
    {
        if (unit_system == "Metric")
        {
            let km = pace / 1000.0;
            return km.toFixed(2).toString() + " mins/km";
        }
        let miles = pace * 609.344;
        return miles.toFixed(2).toString() + " mins/mile";
    }

    /// @function append_to_table_row
    function append_to_table_row(row, text)
    {
        let cell = row.insertCell();
        let a = document.createElement('a');
        let link_text = document.createTextNode(text);

        a.appendChild(link_text);
        a.title = text;
        cell.appendChild(a);
    }

    /// @function append_to_table
    function append_to_table(table, name, value)
    {
        let new_row = table.insertRow();

        append_to_table_row(new_row, name);
        append_to_table_row(new_row, value);
    }

    /// @function on_units_changed
    function on_units_changed()
    {
        let units = document.getElementById('units').value;
        document.cookie = "units=" + units;
    }

    /// @function normalize_split_times
    function normalize_split_times(split_data)
    {
        let new_split_data = [];
        let last_split_value = 0;

        for (let i = 0; i < split_data.length; ++i)
        {
            let new_split_value = split_data[i] - last_split_value;

            last_split_value = split_data[i];
            new_split_data.push(new_split_value);
        }
        return new_split_data;
    }

    /// @function convert_speed_graph_to_display_units
    function convert_speed_graph_to_display_units(unit_system, speed_list)
    {
        let new_speed_list = [];
        let is_metric = (unit_system == "Metric");
        let max = 0.0;

        // Speed is in meters/second.
        for (let data_point in speed_list)
        {
            let date = speed_list[data_point].date;
            let speed = speed_list[data_point].value;
            let value = 0.0;

            if (is_metric)
                value = speed * 3.6;
            else
                value = speed * 2.23694;
            if (value > max)
                max = value;
            new_speed_list.push({date, value}); 
        }
        return [ new_speed_list, max ];
    }

    /// @function convert_speed_graph_to_pace_graph
    function convert_speed_graph_to_pace_graph(unit_system, speed_list)
    {
        let pace_list = [];
        let is_metric = (unit_system == "Metric");
        let min = 0.0;

        // Speed is in meters/second.
        for (let data_point in speed_list)
        {
            let date = speed_list[data_point].date;
            let speed = speed_list[data_point].value;
            let value = 0.0;

            if (speed > 1.25)
            {
                if (is_metric)
                    value = 16.6666667 / speed;
                else
                    value = 26.8224 / speed;
                if (min < 0.1 || value < min)
                    min = value;
            }
            else
                value = 0.0;
            pace_list.push({date, value});
        }
        return [ pace_list, min ];
    }

    /// @function compute_grade_adjusted_pace
    function compute_grade_adjusted_pace(gradient_list, time_pace_data)
    {
        let gap_list = time_pace_data.map(function(x, i) {
            let gradient = gradient_list[i];
            let cost = (155.4 * (Math.pow(gradient, 5))) - (30.4 * Math.pow(gradient, 4)) - (43.4 * Math.pow(gradient, 3)) - (46.3 * (gradient * gradient)) - (19.5 * gradient) + 3.6;
            let value = x.value + (x.value - 3.6) / 3.6;
            return {"date": new Date(x.date), "value": value};
        });
        return gap_list;
    }
</script>

<!-- Note the usage of `type=module` here as this is an ES6 module -->
<script type="module">
    import init, { greet, analyze_gpx, analyze_tcx } from 'https://activity-analyzer.app/pkg/activity_analyzer.js';

    async function run() {
        await init();
    }

    window.analyze_file_data = function analyze_file_data(name, blob) {
        let ext = name.split('.').pop();
        let report = "";

        if (ext == "gpx")
            report = analyze_gpx(blob);
        else
            report = analyze_tcx(blob);

        let units = document.getElementById('units').value;
        let analysis_table = document.getElementById('analysis_table');

        // Show the section
        let section = document.getElementById('analysis');
        section.style = "display: block;";

        // Remove previous table contents, in case the user pressed the button twice.
        analysis_table.innerHTML = ''

        // The data is returned as a JSON string.
        let json_data = JSON.parse(report);

        // Which unit system are we using.
        let speed_units = ""
        let pace_units = ""

        if (units == "Metric")
        {
            speed_units = "kph";
            pace_units = "mins/km";
        }
        else
        {
            speed_units = "mph";
            pace_units = "mins/mile";
        }

        append_to_table(analysis_table, "Start Time", unix_time_ms_to_local_string(json_data["Start Time (ms)"]));
        append_to_table(analysis_table, "End Time", unix_time_ms_to_local_string(json_data["End Time (ms)"]));
        append_to_table(analysis_table, "Elapsed Time", convert_seconds_to_hours_mins_secs(json_data["Elapsed Time"]));
        append_to_table(analysis_table, "Total Distance", convert_distance_to_unit_system_str(units, json_data["Total Distance"]));
        append_to_table(analysis_table, "Total Vertical Distance", convert_vertical_distance_to_unit_system_str(units, json_data["Total Vertical Distance"]));
        append_to_table(analysis_table, "Average Speed", convert_speed_to_unit_system_str(units, json_data["Average Speed"]));

        if (json_data["Best 1K"] > 0)
            append_to_table(analysis_table, "Best 1K", convert_seconds_to_hours_mins_secs(json_data["Best 1K"]));
        if (json_data["Best Mile"] > 0)
            append_to_table(analysis_table, "Best Mile", convert_seconds_to_hours_mins_secs(json_data["Best Mile"]));
        if (json_data["Best 5K"] > 0)
            append_to_table(analysis_table, "Best 5K", convert_seconds_to_hours_mins_secs(json_data["Best 5K"]));
        if (json_data["Best 10K"] > 0)
            append_to_table(analysis_table, "Best 10K", convert_seconds_to_hours_mins_secs(json_data["Best 10K"]));
        if (json_data["Best 15K"] > 0)
            append_to_table(analysis_table, "Best 15K", convert_seconds_to_hours_mins_secs(json_data["Best 15K"]));
        if (json_data["Best Half Marathon"] > 0)
            append_to_table(analysis_table, "Best Half Marathon", convert_seconds_to_hours_mins_secs(json_data["Best Half Marathon"]));
        if (json_data["Best Marathon"] > 0)
            append_to_table(analysis_table, "Best Marathon", convert_seconds_to_hours_mins_secs(json_data["Best Marathon"]));
        if (json_data["Maximum Power"] > 0)
            append_to_table(analysis_table, "Maximum Power", json_data["Maximum Power"].toFixed(2).toString() + " watts");
        if (json_data["Average Power"] > 0)
            append_to_table(analysis_table, "Average Power", json_data["Average Power"].toFixed(2).toString() + " watts");
        if (json_data["5 Second Power"] > 0)
            append_to_table(analysis_table, "5 Second Power", json_data["5 Second Power"].toFixed(2).toString() + " watts");
        if (json_data["12 Minute Power"] > 0)
            append_to_table(analysis_table, "12 Minute Power", json_data["12 Minute Power"].toFixed(2).toString() + " watts");
        if (json_data["20 Minute Power"] > 0)
            append_to_table(analysis_table, "20 Minute Power", json_data["20 Minute Power"].toFixed(2).toString() + " watts");
        if (json_data["1 Hour Power"] > 0)
            append_to_table(analysis_table, "1 Hour Power", json_data["1 Hour Power"].toFixed(2).toString() + " watts");
        if (json_data["Normalized Power"] > 0)
            append_to_table(analysis_table, "Normalized Power", json_data["Normalized Power"].toFixed(2).toString() + " watts");
        if (json_data["Maximum Cadence"] > 0)
            append_to_table(analysis_table, "Maximum Cadence", json_data["Maximum Cadence"].toFixed(2).toString() + " rpm");
        if (json_data["Average Cadence"] > 0)
            append_to_table(analysis_table, "Average Cadence", json_data["Average Cadence"].toFixed(2).toString() + " rpm");
        if (json_data["Maximum Heart Rate"] > 0)
            append_to_table(analysis_table, "Maximum Heart Rate", json_data["Maximum Heart Rate"].toFixed(2).toString() + " bpm");
        if (json_data["Average Heart Rate"] > 0)
            append_to_table(analysis_table, "Average Heart Rate", json_data["Average Heart Rate"].toFixed(2).toString() + " bpm");

        draw_bar_chart(normalize_split_times(json_data["Mile Splits"]), "Split Times (Miles)", "LightSteelBlue");
        draw_bar_chart(normalize_split_times(json_data["KM Splits"]), "Split Times (KM)", "Tomato");

        let times = json_data["Times"];
        let speeds = json_data["Speeds"];
        let power = json_data["Power Readings"];
        let cadence = json_data["Cadence Readings"];
        let hr = json_data["Heart Rate Readings"];
        let altitude = json_data["Altitude Readings"];
        let gradients = json_data["Gradient Curve"];

        let time_speed_data = times.map(function(x, i) {
            return {"date": new Date(x), "value": speeds[i]};
        });
        let [ adjusted_time_speed_data, max_speed ] = convert_speed_graph_to_display_units(units, time_speed_data);
        let [ time_pace_data, min_pace ] = convert_speed_graph_to_pace_graph(units, time_speed_data);
        let gap_data = compute_grade_adjusted_pace(gradients, time_pace_data);

        append_to_table(analysis_table, "Maximum Speed", max_speed.toFixed(2).toString() + " " + speed_units);
        append_to_table(analysis_table, "Minimum Pace", min_pace.toFixed(2).toString() + " " + pace_units);

        draw_graph(adjusted_time_speed_data, "Speed", speed_units, "DodgerBlue");
        draw_graph(time_pace_data, "Pace", pace_units, "SlateBlue");
        draw_graph(gap_data, "Grade Adjusted Pace", pace_units, "SlateBlue");

        if (power.length > 0)
        {
            let time_power_data = times.map(function(x, i) {
                return {"date": new Date(x), "value": power[i]};
            });
            draw_graph(time_power_data, "Power", "Watts", "ForestGreen");
        }
        if (cadence.length > 0)
        {
            let time_cadence_data = times.map(function(x, i) {
                return {"date": new Date(x), "value": cadence[i]};
            });
            draw_graph(time_cadence_data, "Cadence", "rpm", "ForestGreen");
        }
        if (hr.length > 0)
        {
            let time_hr_data = times.map(function(x, i) {
                return {"date": new Date(x), "value": hr[i]};
            });
            draw_graph(time_hr_data, "Heart Rate", "bpm", "FireBrick");
        }
        if (altitude.length > 0)
        {
            let time_altitude_data = times.map(function(x, i) {
                return {"date": new Date(x), "value": altitude[i]};
            });
            draw_graph(time_altitude_data, "Altitude", "meters", "PeachPuff");
        }
    }

    run();
</script>

<section class="settings">
    <div>
        <h1>Select a File</h1>
        <input type="file" id="file_picker" class="modern_button" accept=".gpx,.tcx" name="file_picker" single>
        <button type="button" class="modern_button" onclick="return analyze_selected_files()">Analyze File</button><br>
        <select id="units" onchange="on_units_changed()">
            <option value="Metric">Metric</option>
            <option value="Standard">Standard</option>
        </select>
        <h4>Only GPX and TCX files are supported.<br>Cycling power and cadence data are only read from TCX files.</h4>
    </div>
</section>

<section class="analysis" id="analysis" style="display: none;">
    <div>
        <h1>Analysis</h1>
        <table id="analysis_table">
        </table>
    </div>
</section>

<section class="charts">
    <div id="charts"/>
</section>

<!-- Scripts for loading the file and drawing the graphs -->
<script type="text/javascript">

    var selected_file_list = [];
    var file_picker = document.getElementById('file_picker');

    /// @function draw_graph
    function draw_graph(data, title, units, color)
    {
        if (data.length <= 1)
        {
            return;
        }

        // Need to zero out the first and last points or else the fill will look silly.
        data[0].value = 0.0;
        data[data.length-1].value = 0.0;

        let tooltip = d3.select("#charts")
            .append("div")
                .style("opacity", 0)
                .style("position", "absolute")
                .style("visibility", "hidden")
                .style("background-color", "white")
                .style("z-index", 1)
                .style("cursor", "pointer")
        let mouseover = function() {
            tooltip
                .style("opacity", 0.7)
                .style("visibility", "visible")
        }
        let mousemove = function() {
            let coordinates = d3.mouse(this);
            let x = coordinates[0];

            tooltip
                .html("<b>" + data[x].value.toFixed(2) + " " + units + "</b>")
                .style("top", (event.pageY)+"px")
                .style("left",(event.pageX)+"px")
        }
        let mouseleave = function() {
        }

        let margin = { top: 20, right: 20, bottom: 20, left: 50 },
            width = $("#charts").width() - margin.left - margin.right,
            height = 250 - margin.top - margin.bottom;

        let x = d3.time.scale().range([0, width]);
        let y = d3.scale.linear().range([height, 0]);

        let xAxis = d3.svg.axis().scale(x).orient("bottom");
        let yAxis = d3.svg.axis().scale(y).orient("left").ticks(5);

        let valueline = d3.svg.line()
            .x(function(d) { return x(d.date); })
            .y(function(d) { return y(d.value); });

        let svg = d3.select("#charts")
            .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .on('mouseover', mousemove)
                .on('mousemove', mouseover)
                .on('mouseleave', mouseleave)
            .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        x.domain(d3.extent(data, function(d) { return d.date; }));
        y.domain(d3.extent(data, function(d) { return d.value; }));

        svg.append("path")
            .attr("class", "line")
            .attr("d", valueline(data))
            .style("fill", color)
            .style("stroke", "LightSlateGray")
            .style("stroke-width", 1.25);
        svg.append("g")
            .attr("class", "x axis")
            .attr("transform", "translate(0," + height + ")")
            .call(xAxis);
        svg.append("g")
            .attr("class", "y axis")
            .call(yAxis)
            .append("text")
            .attr("transform", "rotate(-90)")
            .attr("y", 6)
            .attr("dy", ".71em")
            .style("text-anchor", "end")
            .text(title);
    }

    /// @function draw_bar_chart
    function draw_bar_chart(data, title, color)
    {
        let xVals = Array.apply(null, Array(data.length)).map(function (x, i) { return i + 1; } );

        let tooltip = d3.select("#charts")
            .append("div")
                .style("opacity", 0)
                .style("position", "absolute")
                .style("visibility", "hidden")
                .style("background-color", "white")
                .style("z-index", 1)
                .style("cursor", "pointer")
        let mouseover = function() {
            tooltip
                .style("opacity", 0.7)
                .style("visibility", "visible")
        }
        let mousemove = function() {
            let coordinates = d3.mouse(this);
            let x = Math.floor((coordinates[0] / width) * data.length);

            tooltip
                .html("<b>" + convert_seconds_to_hours_mins_secs(data[x]) + "</b>")
                .style("top", (event.pageY)+"px")
                .style("left",(event.pageX)+"px")
        }
        let mouseleave = function() {
        }

        let margin = {top: 20, right: 20, bottom: 55, left: 50},
            width = $("#charts").width() - margin.left - margin.right,
            height = 250 - margin.top - margin.bottom;

        let x = d3.scale.ordinal().domain(xVals).rangeBands([0, width]);
        let y = d3.scale.linear().domain([0, d3.max(data)]).range([height, 0]);

        let xAxis = d3.svg.axis().scale(x).orient("bottom");
        let yAxis = d3.svg.axis().scale(y).orient("left").ticks(0);

        let svg = d3.select("#charts")
            .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .on('mouseover', mousemove)
                .on('mousemove', mouseover)
                .on('mouseleave', mouseleave)
            .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        svg.append("g")
            .attr("class", "x axis")
            .attr("transform", "translate(0," + height + ")")
            .call(xAxis)
            .selectAll("text")
            .style("text-anchor", "end")
            .attr("dx", "-.8em")
            .attr("dy", "-.55em")
            .attr("transform", "rotate(-90)" );
        svg.append("g")
            .attr("class", "y axis")
            .call(yAxis)
            .append("text")
            .attr("transform", "rotate(-90)")
            .attr("dy", ".71em")
            .style("text-anchor", "end");
        svg.append("text")
            .attr("transform", "translate(" + (width/2) + " ," + (height + margin.top + 20) + ")")
            .style("text-anchor", "middle")
            .text(title);
        svg.selectAll("bar")
            .data(data)
            .enter().append("rect")
            .style("fill", color)
            .attr("width", x.rangeBand())
            .attr("height", function(d) { return height - y(d); })
            .attr("x", function(d, i) { return x(i+1); })
            .attr("y", function(d) { return y(d); });
    }

    /// @function draw_intervals_graph
    function draw_intervals_graph(interval_data)
    {
        interval_graph = [];

        if (interval_data.length > 0)
        {
            if (start_time > 0)
            {
                graph_node = {};
                graph_node["date"] = new Date(start_time);
                graph_node["value"] = 0;
                interval_graph.push(graph_node);
            }

            for (let i in interval_data)
            {
                let interval = interval_data[i];
                let start_interval_time = Number(interval[0]);
                let end_interval_time = Number(interval[1]);

                graph_node = {};
                graph_node["date"] = new Date(start_interval_time-1000);
                graph_node["value"] = 0;
                interval_graph.push(graph_node);
                graph_node = {};
                graph_node["date"] = new Date(start_interval_time);
                graph_node["value"] = 1;
                interval_graph.push(graph_node);
                graph_node = {};
                graph_node["date"] = new Date(end_interval_time);
                graph_node["value"] = 1;
                interval_graph.push(graph_node);
                graph_node = {};
                graph_node["date"] = new Date(end_interval_time+1000);
                graph_node["value"] = 0;
                interval_graph.push(graph_node);
            }

            if (end_time > 0)
            {
                graph_node = {};
                graph_node["date"] = new Date(end_time);
                graph_node["value"] = 0;
                interval_graph.push(graph_node);
            }

            draw_graph(interval_graph, "Intervals", "", "Black");
        }
    }

    function analyze_selected_files()
    {
        if (selected_file_list.length > 0)
        {
            for (var i = 0; i < selected_file_list.length; i++)
            {
                var selected_file_obj = selected_file_list[i];
                var reader = new FileReader();

                reader.onerror = function(event)
                {
                    reader.abort();
                };
                reader.onload = function(e)
                {
                    window.analyze_file_data(selected_file_obj.name, reader.result);
                }
                reader.readAsBinaryString(selected_file_obj);
            }
        }
        else
        {
            alert("A file was not specified.");
        }
    }

    function get_cookie(cookie_name)
    {
        let name = cookie_name + "=";
        let decoded_cookie = decodeURIComponent(document.cookie);
        let ca = decoded_cookie.split(';');

        for (let i = 0; i < ca.length; i++)
        {
            let c = ca[i];

            while (c.charAt(0) == ' ') {
                c = c.substring(1);
            }
            if (c.indexOf(name) == 0) {
                return c.substring(name.length, c.length);
            }
        }
        return "";
    }

    $(document).ready(function()
    {
        // Add the on change listener for the file picker.
        file_picker.addEventListener('change', e => {
            for (let file of Array.from(e.target.files))
            {
                selected_file_list.push(file);
            };
        });

        // Set the preferred units.
        let units = get_cookie("units");
        if (units.length == 0)
            document.getElementById('units').value = "Metric";
        else
            document.getElementById('units').value = units;
    });

</script>

<!--
<section class="connections">
    <div>
        <h1>Connected Services</h1>
        <a href="api/connect_to_strava"><img src="../images/connect_to_strava.png" width="256"></a>
    </div>
</section>
-->

<section class="faq">
    <div>
        <h1>Frequently Asked Questions</h1>
        <ul>
            <li>How much does this cost? <p>Nothing</p>
            <li>How does it work? <p>This page is a combination of HTML, Javascript, CSS, and WebAssembly compiled from Rust.</p>
            <li>What data do you store? <p>Nothing. All processing is done in the browser. No data leaves the local machine.</p>
            <li>Can I connect this to Strava, etc.? <p>Not right now, but maybe in the future.</p>
            <li>Can I see the source code? <p>Yes, it is available on <a href="https://github.com/msimms/ActivityAnalyzer">GitHub</a>.</p>
        </ul>
    </div>
</section>

<section class="footer">
    <div>
        <h2>Copyright (c) 2021 Michael J Simms</h2>
    </div>
</section>

</body>

</html>
